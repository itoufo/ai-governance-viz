<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Governance Matrix | 3D Neural Network</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Noto+Sans+JP:wght@300;400;500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --cyan: #00f5ff;
            --magenta: #ff00ff;
            --electric-blue: #0066ff;
            --neon-green: #00ff88;
            --orange: #ff6600;
            --yellow: #ffcc00;
            --purple: #cc00ff;
            --teal: #00ffcc;
            --void: #0a0a0f;
            --deep-void: #030305;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: var(--deep-void);
            color: white;
            overflow: hidden;
            min-height: 100vh;
            cursor: crosshair;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.08) 2px,
                rgba(0, 0, 0, 0.08) 4px
            );
            mix-blend-mode: overlay;
        }

        /* HUD Elements */
        .hud {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .hud-interactive {
            pointer-events: auto;
        }

        /* Top HUD */
        .hud-top {
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px 30px;
        }

        .hud-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .hud-title h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 4px;
            color: var(--cyan);
            text-shadow: 0 0 20px var(--cyan), 0 0 40px var(--cyan);
        }

        .hud-title span {
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: rgba(0, 245, 255, 0.6);
            letter-spacing: 2px;
        }

        /* Stats Panel */
        .stats-panel {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--cyan);
            text-shadow: 0 0 15px var(--cyan);
        }

        .stat-label {
            font-family: 'Share Tech Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* Level / XP Bar */
        .level-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .level-badge {
            width: 50px;
            height: 50px;
            border: 2px solid var(--cyan);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(0, 245, 255, 0.2) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3), inset 0 0 15px rgba(0, 245, 255, 0.1);
        }

        .level-badge span {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 900;
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }

        .xp-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .xp-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cyan), var(--magenta));
            box-shadow: 0 0 10px var(--cyan);
            transition: width 0.5s ease;
            width: 0%;
        }

        .xp-text {
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: rgba(0, 245, 255, 0.7);
        }

        /* Side Panel - Domains */
        .hud-left {
            top: 100px;
            left: 20px;
            width: 280px;
        }

        .domain-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .domain-card {
            background: rgba(0, 10, 20, 0.8);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 6px;
            padding: 12px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
        }

        .domain-card:hover {
            border-color: var(--cyan);
            background: rgba(0, 245, 255, 0.05);
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }

        .domain-card.active {
            border-color: var(--magenta);
            background: rgba(255, 0, 255, 0.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
        }

        .domain-card.completed {
            border-color: var(--neon-green);
        }

        .domain-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 2px solid;
            flex-shrink: 0;
        }

        .domain-info {
            flex: 1;
            min-width: 0;
        }

        .domain-name {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .domain-progress {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .domain-progress-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .domain-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            min-width: 40px;
            text-align: right;
        }

        /* Right Panel - Detail */
        .hud-right {
            top: 100px;
            right: 20px;
            width: 400px;
            max-height: calc(100vh - 140px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .detail-panel {
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(20px);
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.4s ease;
            display: flex;
            flex-direction: column;
            max-height: 100%;
        }

        .detail-panel.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .detail-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
            flex-shrink: 0;
        }

        .detail-domain-id {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            letter-spacing: 3px;
            margin-bottom: 6px;
        }

        .detail-domain-name {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .detail-domain-name .icon {
            font-size: 24px;
        }

        .detail-domain-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.5;
        }

        .detail-content {
            padding: 15px 20px;
            overflow-y: auto;
            flex: 1;
        }

        .detail-content::-webkit-scrollbar {
            width: 4px;
        }

        .detail-content::-webkit-scrollbar-track {
            background: rgba(0, 245, 255, 0.05);
        }

        .detail-content::-webkit-scrollbar-thumb {
            background: var(--cyan);
            border-radius: 2px;
        }

        .process-card {
            background: rgba(0, 245, 255, 0.03);
            border: 1px solid rgba(0, 245, 255, 0.1);
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .process-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            background: var(--cyan);
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .process-card:hover {
            background: rgba(0, 245, 255, 0.08);
            border-color: rgba(0, 245, 255, 0.3);
            transform: translateX(3px);
        }

        .process-card:hover::before {
            opacity: 1;
            box-shadow: 0 0 10px var(--cyan);
        }

        .process-card.checked {
            border-color: var(--neon-green);
        }

        .process-card.checked::before {
            background: var(--neon-green);
        }

        .process-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .process-code {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border: 1px solid;
            border-radius: 3px;
        }

        .process-name {
            font-size: 12px;
            font-weight: 700;
        }

        .process-check {
            margin-left: auto;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .process-card.checked .process-check {
            background: var(--neon-green);
            border-color: var(--neon-green);
            box-shadow: 0 0 15px var(--neon-green);
        }

        .process-text {
            font-size: 11px;
            line-height: 1.7;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Bottom HUD */
        .hud-bottom {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .control-btn {
            background: rgba(0, 10, 20, 0.8);
            border: 1px solid var(--cyan);
            border-radius: 6px;
            padding: 10px 20px;
            color: var(--cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: var(--cyan);
            color: var(--deep-void);
            box-shadow: 0 0 30px var(--cyan);
        }

        .control-btn.active {
            background: var(--magenta);
            border-color: var(--magenta);
            color: white;
            box-shadow: 0 0 30px var(--magenta);
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95) 0%, rgba(10, 10, 30, 0.95) 100%);
            border: 2px solid var(--neon-green);
            border-radius: 12px;
            padding: 30px 50px;
            text-align: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.4);
        }

        .achievement-popup.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .achievement-icon {
            font-size: 60px;
            margin-bottom: 15px;
            animation: achievementBounce 0.6s ease infinite;
        }

        @keyframes achievementBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .achievement-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--neon-green);
            letter-spacing: 3px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px var(--neon-green);
        }

        .achievement-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .achievement-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .achievement-xp {
            margin-top: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--yellow);
            text-shadow: 0 0 15px var(--yellow);
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 10, 20, 0.8);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            z-index: 100;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-label {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Share Tech Mono', monospace;
            font-size: 8px;
            color: rgba(0, 245, 255, 0.5);
            letter-spacing: 1px;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: rgba(0, 245, 255, 0.4);
        }

        .instructions div {
            margin-bottom: 4px;
        }

        .key {
            display: inline-block;
            padding: 2px 6px;
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 3px;
            margin-right: 5px;
            font-size: 9px;
        }

        /* Particle effects overlay */
        .particles-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Glitch effect */
        .glitch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            background: linear-gradient(90deg,
                rgba(255,0,255,0.1) 0%,
                transparent 50%,
                rgba(0,255,255,0.1) 100%
            );
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(0, 10, 20, 0.95);
            border: 1px solid var(--cyan);
            border-radius: 6px;
            padding: 10px 15px;
            font-size: 11px;
            max-width: 250px;
            z-index: 3000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    <div class="scanlines"></div>
    <div class="glitch-overlay" id="glitchOverlay"></div>
    <canvas class="particles-overlay" id="particlesOverlay"></canvas>

    <!-- Top HUD -->
    <div class="hud hud-top">
        <div class="hud-title">
            <h1>AI GOVERNANCE MATRIX</h1>
            <span>NEURAL NETWORK VISUALIZATION v3.0</span>
        </div>

        <div class="stats-panel hud-interactive">
            <div class="stat-item">
                <div class="stat-value" id="checkedCount">0</div>
                <div class="stat-label">CHECKED</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalCount">64</div>
                <div class="stat-label">TOTAL</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="completionRate">0%</div>
                <div class="stat-label">COMPLETION</div>
            </div>
        </div>

        <div class="level-container hud-interactive">
            <div class="level-badge">
                <span id="levelNum">1</span>
            </div>
            <div class="xp-container">
                <div class="xp-bar">
                    <div class="xp-fill" id="xpFill"></div>
                </div>
                <div class="xp-text"><span id="currentXP">0</span> / <span id="maxXP">100</span> XP</div>
            </div>
        </div>
    </div>

    <!-- Left Panel - Domain List -->
    <div class="hud hud-left hud-interactive">
        <div class="domain-list" id="domainList"></div>
    </div>

    <!-- Right Panel - Detail -->
    <div class="hud hud-right hud-interactive">
        <div class="detail-panel" id="detailPanel">
            <div class="detail-header" id="detailHeader">
                <div class="detail-domain-id" id="detailDomainId">DOMAIN.01</div>
                <div class="detail-domain-name" id="detailDomainName">
                    <span class="icon">üëÅ</span>
                    <span>‰∫∫ÈñìÁõ£Áù£</span>
                </div>
                <div class="detail-domain-desc" id="detailDomainDesc">AI„ÅÆÂà§Êñ≠„Å´ÂØæ„Åô„Çã‰∫∫Èñì„ÅÆÊúÄÁµÇÊ±∫ÂÆöÊ®©„Éª‰ªãÂÖ•„Éª„Ç™„Éº„Éê„Éº„É©„Ç§„ÉâÊ©üËÉΩ„ÅÆÁ¢∫‰øù</div>
            </div>
            <div class="detail-content" id="detailContent"></div>
        </div>
    </div>

    <!-- Bottom Controls -->
    <div class="hud hud-bottom hud-interactive">
        <button class="control-btn" id="btnRotate" onclick="toggleAutoRotate()">AUTO ROTATE</button>
        <button class="control-btn" id="btnReset" onclick="resetCamera()">RESET VIEW</button>
        <button class="control-btn" id="btnExport" onclick="exportProgress()">EXPORT DATA</button>
    </div>

    <!-- Minimap -->
    <div class="minimap">
        <canvas class="minimap-canvas" id="minimapCanvas"></canvas>
        <div class="minimap-label">ORBITAL VIEW</div>
    </div>

    <!-- Instructions -->
    <div class="instructions">
        <div><span class="key">DRAG</span> Rotate View</div>
        <div><span class="key">SCROLL</span> Zoom</div>
        <div><span class="key">CLICK</span> Select Node</div>
    </div>

    <!-- Achievement Popup -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon" id="achievementIcon">üèÜ</div>
        <div class="achievement-title">ACHIEVEMENT UNLOCKED</div>
        <div class="achievement-name" id="achievementName">First Steps</div>
        <div class="achievement-desc" id="achievementDesc">Complete your first checklist item</div>
        <div class="achievement-xp" id="achievementXP">+50 XP</div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // ============ DATA ============
        const domainData = [
            {
                id: '01', name: '‰∫∫ÈñìÁõ£Áù£', nameEn: 'Human Oversight', icon: 'üëÅ',
                color: '#00f5ff',
                desc: 'AI„ÅÆÂà§Êñ≠„Å´ÂØæ„Åô„Çã‰∫∫Èñì„ÅÆÊúÄÁµÇÊ±∫ÂÆöÊ®©„Éª‰ªãÂÖ•„Éª„Ç™„Éº„Éê„Éº„É©„Ç§„ÉâÊ©üËÉΩ„ÅÆÁ¢∫‰øù',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AI„ÅÆÂà§Êñ≠„Å´ÂØæ„Åó„Å¶„ÄÅ‰∫∫Èñì„ÅåÊúÄÁµÇÊ±∫ÂÆö„ÇÑÊâøË™ç„ÇíË°å„ÅÜÁØÑÂõ≤„ÉªÊ®©Èôê„ÉªË≤¨‰ªªËÄÖ„ÅåÊòéÁ¢∫„Å´Ë¶èÂÆö„ÉªÊñáÊõ∏Âåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: '‰∫∫Èñì„ÅÆ‰ªãÂÖ•ÔºàHIC/HITLÔºâ„Åå‰∏çÂèØÊ¨†„Å™È´ò„É™„Çπ„ÇØ„Å™Âà©Áî®„Ç∑„Éä„É™„Ç™„ÇÑ‰æãÂ§ñ„Ç±„Éº„Çπ„ÅåÁâπÂÆö„ÉªË©ï‰æ°„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: 'Áï∞Â∏∏ÊôÇ„Å´‰∫∫Èñì„ÅåÂç≥Â∫ß„Å´AI„ÇíÂÅúÊ≠¢„ÄÅ„Åæ„Åü„ÅØÂà§Êñ≠„Çí‰∏äÊõ∏„ÅçÔºà„Ç™„Éº„Éê„Éº„É©„Ç§„ÉâÔºâ„Åß„Åç„ÇãÊ©üËÉΩ„ÅåÂÆüË£Ö„ÉªÊ§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: '‰∫∫Èñì„Å´„Çà„ÇãÊâøË™ç„ÄÅ‰ªãÂÖ•„ÄÅ‰∏äÊõ∏„ÅçÊìç‰Ωú„ÅÆË®òÈå≤„Åå„ÄÅÁõ£ÊüªË®ºË∑°„Å®„Åó„Å¶Á¢∫ÂÆü„Å´‰øùÂÖ®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'AI„ÅÆÂà§Êñ≠Á≤æÂ∫¶Âä£Âåñ„ÇÑÊö¥Ëµ∞„ÅÆÂÖÜÂÄô„ÇíÊ§úÁü•„Åó„ÄÅÁõ£Áù£ËÄÖ„Å∏Âç≥Â∫ß„Å´ÈÄöÁü•„Åô„ÇãÁõ£Ë¶ñ‰ΩìÂà∂„Åå„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: '‰∫∫Èñì„Åå‰ªãÂÖ•„Åó„Å¶AI„ÇíÂÅúÊ≠¢„Åï„Åõ„ÅüÂæå„ÄÅÊâãÂãïÊ•≠Âãô„Å∏„ÅÆÂàá„ÇäÊõø„Åà„ÇÑÂÆâÂÖ®„Å™Âæ©Êóß„ÇíË°å„ÅÜÊâãÈ†Ü„ÅåÊï¥ÂÇô„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'ÈáçË¶Å„Å™Ê±∫ÂÆö„Å´Èöõ„Åó„Å¶„Äå‰∫∫Èñì„ÅåÈñ¢‰∏é„Åó„Å¶„ÅÑ„Çã„Äç‰∫ãÂÆü„Çí„ÄÅÂà©Áî®ËÄÖ„ÇÑÈñ¢‰øÇËÄÖ„Å∏ÈÅ©Âàá„Å´Ë™¨Êòé„ÉªÈÄöÁü•„Åß„Åç„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: '‰∫∫ÈñìÁõ£Áù£„ÅåÊ©üËÉΩ„Åó„Å™„Åã„Å£„Åü‰∫ã‰æã„ÇÑ„Éí„É§„É™„Éè„ÉÉ„Éà„ÇíÂàÜÊûê„Åó„ÄÅÁõ£Áù£‰ΩìÂà∂„ÇÑ‰ªãÂÖ•Âü∫Ê∫ñ„ÅÆË¶ãÁõ¥„Åó„ÇíË°å„Å£„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '02', name: '„Éó„É©„Ç§„Éê„Ç∑„Éº', nameEn: 'Privacy', icon: 'üîê',
                color: '#ff00ff',
                desc: 'ÂÄã‰∫∫ÊÉÖÂ†±‰øùË≠∑„Å®„Éá„Éº„Çø„ÅÆÈÅ©Ê≠£„Å™ÁÆ°ÁêÜ„ÉªÂà©Áî®„ÅÆÁ¢∫‰øù',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'ÂÄã‰∫∫ÊÉÖÂ†±‰øùË≠∑ÊñπÈáù„ÄÅ„Éá„Éº„Çø„ÅÆÁõÆÁöÑÂ§ñÂà©Áî®Á¶ÅÊ≠¢„ÄÅÊúÄÂ∞èÂåñ„ÅÆÂéüÂâá„ÅåË¶èÂÆö„Åï„Çå„ÄÅË≤¨‰ªªËÄÖ„ÅåÊòéÁ¢∫„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'AIÂà©Áî®„Å´‰º¥„ÅÜ„Éó„É©„Ç§„Éê„Ç∑„ÉºÂΩ±ÈüøË©ï‰æ°ÔºàPIAÔºâ„ÇíÂÆüÊñΩ„Åó„ÄÅ„Éá„Éº„Çø‰∏ª‰Ωì„ÅÆÊ®©Âà©‰æµÂÆ≥„É™„Çπ„ÇØ„ÇíË©ï‰æ°„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: '„Éó„É©„Ç§„Éê„Ç∑„Éº‰øùË≠∑ÊäÄË°ìÔºàÂåøÂêçÂåñ„ÄÅÁßòÂØÜË®àÁÆóÁ≠âÔºâ„ÅÆÂ∞éÂÖ•„ÇÑ„ÄÅÂ≠¶Áøí„Éá„Éº„Çø„Åã„Çâ„ÅÆ‰∏çÈÅ©Âàá„Å™ÂÄã‰∫∫ÁâπÂÆöÊéíÈô§„ÅåÊ§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'Â≠¶Áøí„ÉªÊé®Ë´ñ„Å´Áî®„ÅÑ„Çã„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆÂè∞Â∏≥„ÅåÊï¥ÂÇô„Åï„Çå„ÄÅÂà©Áî®Â±•Ê≠¥„ÄÅ„Ç¢„ÇØ„Çª„Çπ„É≠„Ç∞„ÄÅÂâäÈô§Ë®òÈå≤„Åå‰øùÂÖ®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'ÁõÆÁöÑÂ§ñ„ÅÆ„Éá„Éº„Çø„Ç¢„ÇØ„Çª„Çπ„ÇÑ„ÄÅÁï∞Â∏∏„Å™„Éá„Éº„ÇøÊåÅ„Å°Âá∫„ÅóÁ≠â„ÇíÊ§úÁü•„Åô„Çã‰ªïÁµÑ„Åø„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: '„Éá„Éº„ÇøÊºè„Åà„ÅÑÁô∫ÁîüÊôÇ„Å´„ÄÅÂØæË±°„Éá„Éº„Çø„ÅÆÈöîÈõ¢„ÇÑ„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„ÅÆÂÅúÊ≠¢„ÇíËøÖÈÄü„Å´Ë°å„ÅÜÊâãÈ†Ü„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: '„Éá„Éº„Çø‰∏ª‰Ωì„Åã„Çâ„ÅÆÈñãÁ§∫„ÉªË®ÇÊ≠£„ÉªÂâäÈô§Ë´ãÊ±ÇÔºà„Ç™„Éó„Éà„Ç¢„Ç¶„ÉàÂê´„ÇÄÔºâ„Å´ÂØæÂøú„Åô„ÇãÊâãÈ†Ü„Å®‰ΩìÂà∂„ÅØÁ¢∫Á´ã„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: '„Éá„Éº„ÇøÂèñ„ÇäÊâ±„ÅÑ„Å´Èñ¢„Åô„Çã„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÇÑÊ≥ï‰ª§ÊîπÊ≠£„Å´Âü∫„Å•„Åç„ÄÅ„Ç¨„Éê„Éä„É≥„Çπ‰ΩìÂà∂„ÇíÁ∂ôÁ∂öÁöÑ„Å´ÊîπÂñÑ„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '03', name: 'ÈÄèÊòéÊÄß', nameEn: 'Transparency', icon: '‚óá',
                color: '#00ff88',
                desc: 'AIÂà©Áî®„ÅÆÈñãÁ§∫„Å®ËÉΩÂäõ„ÉªÈôêÁïå„ÅÆÈÅ©Âàá„Å™Ë™¨Êòé',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AI„ÅÆÂà©Áî®ÁõÆÁöÑ„ÄÅËÉΩÂäõ„ÅÆÈôêÁïå„ÄÅÂâçÊèêÊù°‰ª∂„ÇíÂà©Áî®ËÄÖ„Å∏ÈñãÁ§∫„Åô„ÇãÊñπÈáù„ÅåÂÆö„ÇÅ„Çâ„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'ÈÄèÊòéÊÄß„ÅÆÊ¨†Â¶Ç„ÅåÂà©Áî®ËÄÖ„ÅÆË™§Ëß£„ÇÑË™§Áî®„ÇíÊãõ„Åè„É™„Çπ„ÇØ„ÇíË©ï‰æ°„Åó„ÄÅÈñãÁ§∫„Åô„Åπ„ÅçÊÉÖÂ†±„É¨„Éô„É´„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: 'Âà©Áî®ËÄÖ„Åå„ÄåAI„Å®ÂØæË©±„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Äç„ÇíË™çË≠ò„Åß„Åç„ÇãUI/UX„ÅåË®≠Ë®à„Åï„Çå„ÄÅË™§Ë™çÈò≤Ê≠¢„ÅåÊ§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'Âà©Áî®ËÄÖ„Å´ÂØæ„Åó„Å¶„ÅÑ„Å§„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å™ÊÉÖÂ†±„ÇíÈñãÁ§∫„ÉªË™¨Êòé„Åó„Åü„Åã„ÅÆË®òÈå≤Ôºà„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜÂê´„ÇÄÔºâ„Çí‰øùÂÖ®„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'Âà©Áî®ËÄÖ„Åã„Çâ„ÅÆ„ÄåÂàÜ„Åã„Çä„Å´„Åè„ÅÑ„Äç„ÄåË™§Ëß£„Åó„Åü„Äç„Å®„ÅÑ„Å£„Åü„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„ÇÑËã¶ÊÉÖ„ÇíÊ§úÁü•„ÉªÂèéÈõÜ„Åô„ÇãÁ™ìÂè£„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: 'AI„ÅÆË°®Á§∫ÂÜÖÂÆπ„Å´ÈáçÂ§ß„Å™Ë™§„Çä„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥Âêà„ÄÅÂç≥Â∫ß„Å´‰øÆÊ≠£ÊÉÖÂ†±„ÇÑÊ≥®ÊÑèÂñöËµ∑„ÇíÂà©Áî®ËÄÖ„Å∏ÈÄöÁü•„Åô„ÇãÊâãÈ†Ü„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: '„Çπ„ÉÜ„Éº„ÇØ„Éõ„É´„ÉÄ„ÉºÔºàÈ°ßÂÆ¢„ÄÅÂèñÂºïÂÖàÁ≠âÔºâ„Å´ÂØæ„Åó„ÄÅAI„Ç∑„Çπ„ÉÜ„É†„ÅÆÊ¶ÇË¶Å„ÇÑ„É™„Çπ„ÇØÊÉÖÂ†±„ÇíÈÅ©Âàá„Å´ÈñãÁ§∫„ÉªË™¨Êòé„Åß„Åç„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: 'Âà©Áî®ËÄÖ„ÅÆÁêÜËß£Â∫¶Ë™øÊüª„ÇÑË™§Áî®‰∫ã‰æã„Å´Âü∫„Å•„Åç„ÄÅË™¨ÊòéÂÜÖÂÆπ„ÇÑUI„ÅÆÊîπÂñÑ„ÇíÁ∂ôÁ∂öÁöÑ„Å´Ë°å„Å£„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '04', name: 'ÂÖ¨Âπ≥ÊÄß', nameEn: 'Fairness', icon: '‚öñ',
                color: '#0066ff',
                desc: 'Â∑ÆÂà•„Éª„Éê„Ç§„Ç¢„Çπ„ÅÆÈò≤Ê≠¢„Å®ÂÖ¨Âπ≥„Å™Âà§Êñ≠„ÅÆÁ¢∫‰øù',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AI„Å´„Çà„ÇãÂ∑ÆÂà•ÔºàÁâπÂÆö„ÅÆÂ±ûÊÄß„Å∏„ÅÆ‰∏çÂà©Áõä„Å™Êâ±„ÅÑÔºâ„ÇíÁ¶ÅÊ≠¢„Åô„ÇãÊñπÈáù„Å®„ÄÅÂÖ¨Âπ≥ÊÄß„ÅÆÂÆöÁæ©„ÉªÊåáÊ®ô„ÅåÊòéÁ¢∫Âåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'Â≠¶Áøí„Éá„Éº„Çø„ÇÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†„Å´Âê´„Åæ„Çå„Çã„Éê„Ç§„Ç¢„Çπ„Åå„ÇÇ„Åü„Çâ„ÅôÂ∑ÆÂà•ÁöÑÂΩ±Èüø„ÅÆ„É™„Çπ„ÇØ„ÇíË©ï‰æ°„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: '„É™„É™„Éº„ÇπÂâç„Å´„ÄÅÂÆöÁæ©„Åó„ÅüÂÖ¨Âπ≥ÊÄßÊåáÊ®ô„Å´Âü∫„Å•„ÅÑ„Åü„Éê„Ç§„Ç¢„ÇπÊ§úÁü•„ÉÜ„Çπ„Éà„ÇÑÁ∑©ÂíåÊé™ÁΩÆ„ÅÆÊúâÂäπÊÄßÊ§úË®º„ÇíË°å„Å£„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'ÂÖ¨Âπ≥ÊÄßÊ§úË®º„Å´‰ΩøÁî®„Åó„Åü„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÄÅË©ï‰æ°ÊåáÊ®ô„ÄÅ„ÉÜ„Çπ„ÉàÁµêÊûú„ÅÆË®òÈå≤„Åå‰øùÂÖ®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'ÈÅãÁî®‰∏≠„ÅÆAIÂá∫Âäõ„Å´ÁâπÂÆö„ÅÆÂ±§„Å∏„ÅÆÂÅè„Çä„ÅåÁîü„Åò„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÁ∂ôÁ∂öÁöÑ„Å´„É¢„Éã„Çø„É™„É≥„Ç∞„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: 'Â∑ÆÂà•ÁöÑ„Å™Âá∫Âäõ„ÅåÊ§úÁü•„Åï„Çå„ÅüÂ†¥Âêà„ÄÅÂΩìË©≤„É¢„Éá„É´„ÅÆÂà©Áî®ÂÅúÊ≠¢„ÇÑ„É≠„Éº„É´„Éê„ÉÉ„ÇØ„ÇíË°å„ÅÜÊâãÈ†Ü„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'AI„ÅÆÂà§Êñ≠„Å´„Çà„Å£„Å¶‰∏çÂà©Áõä„ÇíË¢´„Å£„Åü„Å®ÊÑü„Åò„ÅüÂà©Áî®ËÄÖ„Åã„Çâ„ÅÆÁî≥Á´ã„Å¶„ÇíÂèó„Åë‰ªò„Åë„ÄÅÊïëÊ∏à„Åô„Çã„Éó„É≠„Çª„Çπ„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: '„Éê„Ç§„Ç¢„ÇπÊ§úÁü•„ÅÆÁµêÊûú„ÇÑÁî≥Á´ã„Å¶ÂÜÖÂÆπ„Å´Âü∫„Å•„Åç„ÄÅÂ≠¶Áøí„Éá„Éº„Çø„ÅÆË¶ãÁõ¥„Åó„ÇÑ„É¢„Éá„É´„ÅÆÂÜçÂ≠¶Áøí„ÇíÂÆüÊñΩ„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '05', name: 'ÂÆâÂÖ®ÊÄß', nameEn: 'Safety', icon: 'üõ°',
                color: '#ff6600',
                desc: 'AI„Ç∑„Çπ„ÉÜ„É†„Å´ÂØæ„Åô„ÇãÊîªÊíÉÂØæÁ≠ñ„Å®Â†ÖÁâ¢ÊÄß„ÅÆÁ¢∫‰øù',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AI„Ç∑„Çπ„ÉÜ„É†Âõ∫Êúâ„ÅÆËÑÖÂ®ÅÔºàÊïµÂØæÁöÑÊîªÊíÉ„ÄÅ„Éó„É≠„É≥„Éó„ÉàÊ≥®ÂÖ•Á≠âÔºâ„ÇíÂê´„ÇÄ„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂØæÁ≠ñÂü∫Ê∫ñ„ÅåË¶èÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'AI„Å´ÂØæ„Åô„ÇãÊîªÊíÉ„ÇÑÊÇ™Áî®„Åå‰∫ãÊ•≠„ÇÑÂà©Áî®ËÄÖ„Å´‰∏é„Åà„ÇãÂΩ±ÈüøÂ∫¶Ôºà„Çª„Éº„Éï„ÉÜ„Ç£„É™„Çπ„ÇØÂê´„ÇÄÔºâ„ÇíË©ï‰æ°„ÉªÂàÜÈ°û„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: '„É¢„Éá„É´„ÅÆÂ†ÖÁâ¢ÊÄßÔºà„É≠„Éê„Çπ„Éà„Éç„ÇπÔºâÊ§úË®º„ÇÑ„É¨„ÉÉ„Éâ„ÉÅ„Éº„Éü„É≥„Ç∞„ÇíÂÆüÊñΩ„Åó„ÄÅ„Ç¨„Éº„Éâ„É¨„Éº„É´Ê©üËÉΩ„ÅÆÂÆüÂäπÊÄß„ÇíÁ¢∫Ë™ç„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'AI„É¢„Éá„É´„ÄÅÂ≠¶Áøí„Éá„Éº„ÇøÁ≠â„ÅÆÈáçË¶ÅË≥áÁî£„ÅåÂè∞Â∏≥ÁÆ°ÁêÜ„Åï„Çå„ÄÅÊîπ„Åñ„ÇìÊ§úÁü•„ÇÑ„Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°„Åå„É≠„Ç∞„ÅßÊãÖ‰øù„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'AI„Å∏„ÅÆÁï∞Â∏∏„Å™ÂÖ•ÂäõÔºàÊîªÊíÉÁöÑ„Å™„Éó„É≠„É≥„Éó„ÉàÁ≠âÔºâ„ÇÑ‰∏çÊ≠£„Å™ÊåôÂãï„Çí„É™„Ç¢„É´„Çø„Ç§„É†„ÅßÊ§úÁü•„Åô„Çã‰ªïÁµÑ„Åø„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: '„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Ç§„É≥„Ç∑„Éá„É≥„ÉàÁô∫ÁîüÊôÇ„ÅÆ„Ç∑„Çπ„ÉÜ„É†ÈöîÈõ¢„ÄÅË¢´ÂÆ≥Êã°Â§ßÈò≤Ê≠¢„ÄÅÂÆâÂÖ®„Å™Âæ©ÊóßÊâãÈ†Ü„ÅåÁ¢∫Á´ã„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'ÊîªÊíÉ„Å´„Çà„ÇãÊÉÖÂ†±Êºè„Åà„ÅÑ„ÇÑ„Çµ„Éº„Éì„ÇπÂÅúÊ≠¢„ÅåÁô∫Áîü„Åó„ÅüÈöõ„ÄÅÈñ¢‰øÇÂΩìÂ±Ä„ÇÑË¢´ÂÆ≥ËÄÖ„Å∏„ÅÆÈÄöÁü•„Éï„É≠„Éº„ÅØÊï¥ÂÇô„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: 'Êñ∞„Åü„Å™ÊîªÊíÉÊâãÊ≥ï„ÇÑ„Ç§„É≥„Ç∑„Éá„É≥„ÉàÂàÜÊûê„Å´Âü∫„Å•„Åç„ÄÅÈò≤Âæ°„É¢„Éá„É´„ÇÑ„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂØæÁ≠ñ„ÇíËøÖÈÄü„Å´„Ç¢„ÉÉ„Éó„Éá„Éº„Éà„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '06', name: 'Ë™¨ÊòéË≤¨‰ªª', nameEn: 'Accountability', icon: 'üìã',
                color: '#ffcc00',
                desc: 'ÂΩπÂâ≤„Å®Ë≤¨‰ªª„ÅÆÊòéÁ¢∫Âåñ„Åä„Çà„Å≥Âà§Êñ≠Ê†πÊã†„ÅÆË™¨ÊòéËÉΩÂäõ',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AI„Ç∑„Çπ„ÉÜ„É†„Å´Èñ¢„Çè„ÇãÈñãÁô∫ËÄÖ„ÄÅÊèê‰æõËÄÖ„ÄÅÂà©Áî®ËÄÖ„ÅÆÂΩπÂâ≤„Å®Ë≤¨‰ªªÂàÜÁïåÁÇπ„ÅåÊòéÁ¢∫„Å´ÂÆöÁæ©„ÉªÊñáÊõ∏Âåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'AI„ÅÆÂà§Êñ≠ÁµêÊûú„Å´ÂØæ„Åô„ÇãË™¨Êòé„ÅåÊ±Ç„ÇÅ„Çâ„Çå„Çã„É¨„Éô„É´ÔºàÈáçÂ§ßÂ∫¶Ôºâ„Å´Âøú„Åò„ÄÅÂøÖË¶Å„Å™Ë™¨ÊòéËÉΩÂäõ„ÇíÂÆöÁæ©„ÉªË©ï‰æ°„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: 'AI„ÅÆÊé®Ë´ñÁµêÊûú„ÅÆÊ†πÊã†ÔºàÁâπÂæ¥Èáè„ÅÆÂØÑ‰∏éÂ∫¶Á≠âÔºâ„ÇíÊèêÁ§∫„Åô„ÇãÊäÄË°ìÔºàXAIÔºâ„ÇÑÊâãÊ≥ï„ÅåÂ∞éÂÖ•„ÉªÊ§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'ÂÄãÂà•„ÅÆÂà§Êñ≠ÁµêÊûú„Å´„Å§„ÅÑ„Å¶„ÄÅ„Äå„Å™„Åú„Åù„ÅÆÁµêË´ñ„Å´Ëá≥„Å£„Åü„Åã„Äç„Çí‰∫ãÂæåÁöÑ„Å´ËøΩË∑°„ÉªË™¨Êòé„Åß„Åç„ÇãË®ºË∑°„ÅåË®òÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'Ë™¨Êòé„ÅåÂõ∞Èõ£„Å™ÊåôÂãï„ÇÑ„ÄÅË≤¨‰ªª„ÅÆÊâÄÂú®„ÅåÊõñÊòß„Å´„Å™„Çä„ÅÜ„ÇãÁä∂Ê≥Å„ÇíÊ§úÁü•„Åô„Çã‰ªïÁµÑ„Åø„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: 'Ë≤¨‰ªªËøΩÂèä„ÅåÁô∫Áîü„Åó„ÅüÈöõ„ÅÆÂØæÂøú„ÉÅ„Éº„É†ÁµÑÊàêÊâãÈ†Ü„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'AI„ÅÆÂà§Êñ≠ÁµêÊûú„Å´„Å§„ÅÑ„Å¶Áõ£Êüª‰∫∫„ÇÑÂΩìÂ±Ä„Åã„ÇâË™¨Êòé„ÇíÊ±Ç„ÇÅ„Çâ„Çå„ÅüÈöõ„ÄÅÂêàÁêÜÁöÑ„Å™Ê†πÊã†„Å´Âü∫„Å•„ÅçÂõûÁ≠î„Åß„Åç„Çã‰ΩìÂà∂„Åå„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: 'Ë™¨ÊòéË≤¨‰ªª„ÇíÊûú„Åü„Åõ„Å™„Åã„Å£„Åü‰∫ã‰æã„Å´Âü∫„Å•„Åç„ÄÅË®òÈå≤„Éó„É≠„Çª„Çπ„ÇÑË≤¨‰ªªÂàÜÁïåÁÇπ„ÅÆË¶ãÁõ¥„Åó„ÇíË°å„Å£„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '07', name: '„Ç≥„É≥„Éó„É©„Ç§„Ç¢„É≥„Çπ', nameEn: 'Compliance', icon: '‚öô',
                color: '#cc00ff',
                desc: 'Ê≥ï‰ª§ÈÅµÂÆà„Å®ÂÜÖÈÉ®Áµ±Âà∂„ÅÆÁ¢∫‰øù',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AIÂà©Ê¥ªÁî®„Å´Èñ¢„Åô„ÇãÂÖ®Á§æÁöÑ„Å™Âü∫Êú¨ÊñπÈáù„ÄÅÈÅ©Áî®Ê≥ï‰ª§„ÄÅÂÜÖÈÉ®Ë¶èÁ®ã‰ΩìÁ≥ª„ÅåÊï¥ÂÇô„ÉªÂë®Áü•„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'ÈÅ©Áî®„Åï„Çå„ÇãÊ≥ï‰ª§„ÉªË¶èÂà∂ÔºàËëó‰ΩúÊ®©Ê≥ï„ÄÅÂÄã‰∫∫ÊÉÖÂ†±‰øùË≠∑Ê≥ï„ÄÅÊ•≠Ê≥ïÁ≠âÔºâÂèä„Å≥Â•ëÁ¥Ñ‰∏ä„ÅÆÁæ©ÂãôÈÅïÂèç„É™„Çπ„ÇØ„ÇíÁâπÂÆö„ÉªË©ï‰æ°„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: 'Â§ñÈÉ®ÂßîË®óÂÖà„ÇÑÂà©Áî®„Åô„ÇãSaaS„ÅÆÈÅ∏ÂÆöÂü∫Ê∫ñ„Å´AI„Ç¨„Éê„Éä„É≥„ÇπË¶Å‰ª∂„ÅåÂê´„Åæ„Çå„ÄÅÂ•ëÁ¥ÑÂâç„Å´Ê§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: '„Ç¨„Éê„Éä„É≥„ÇπÊ¥ªÂãï„ÅÆË®òÈå≤Ôºà‰ºöË≠∞Ë≠∞‰∫ãÈå≤„ÄÅÊâøË™çË®òÈå≤„ÄÅÁõ£ÊüªÂ†±ÂëäÊõ∏Á≠âÔºâ„ÅåÈÅ©Âàá„Å´‰øùÁÆ°„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'Ê≥ï‰ª§ÈÅïÂèç„ÇÑÂÜÖÈÉ®Ë¶èÁ®ãÈÅïÂèç„ÅÆ‰∫àÂÖÜ„ÇíÊ§úÁü•„Åô„ÇãÂÜÖÈÉ®ÈÄöÂ†±Âà∂Â∫¶„ÇÑ„É¢„Éã„Çø„É™„É≥„Ç∞‰ΩìÂà∂„ÅØÊ©üËÉΩ„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: 'ÈáçÂ§ß„Å™„Ç≥„É≥„Éó„É©„Ç§„Ç¢„É≥„ÇπÈÅïÂèç„ÅåÁô∫Ë¶ö„Åó„ÅüÈöõ„ÅÆÂç≥ÊôÇÂ†±Âëä„É´„Éº„Éà„Å®Á∑äÊÄ•ÂØæÂøú‰ΩìÂà∂„ÅØÊï¥ÂÇô„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'Ë¶èÂà∂ÂΩìÂ±Ä„Å∏„ÅÆÂ†±ÂëäÁæ©Âãô„ÇÑ„ÄÅÂ§ñÈÉ®Áõ£Êüª„Å∏„ÅÆÂØæÂøúÊâãÈ†Ü„ÅåÊòéÁ¢∫Âåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: 'ÂÆöÊúüÁöÑ„Å™ÂÜÖÈÉ®Áõ£Êüª„ÇÑÂ§ñÈÉ®Ë©ï‰æ°„ÇíÂÆüÊñΩ„Åó„ÄÅÊåáÊëò‰∫ãÈ†Ö„Å´Âü∫„Å•„ÅÑ„Å¶„Ç¨„Éê„Éä„É≥„Çπ‰ΩìÂà∂„ÇíÁ∂ôÁ∂öÁöÑ„Å´ÊîπÂñÑ„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            },
            {
                id: '08', name: '„É°„É≥„Çø„É´ÊåÅÁ∂öÊÄß', nameEn: 'Mental Sustainability', icon: '‚ô°',
                color: '#00ffcc',
                desc: 'ÂæìÊ•≠Âì°„ÉªÂà©Áî®ËÄÖ„ÅÆÂøÉÁêÜÁöÑË≤†Ëç∑„Å∏„ÅÆÈÖçÊÖÆ„Å®‰∫∫Èñì‰∏≠ÂøÉ„ÅÆÈÅãÁî®',
                processes: [
                    { code: 'R1', name: 'ÊñπÈáù„ÉªË≤¨‰ªª', text: 'AIÂà©Ê¥ªÁî®„ÅåÂæìÊ•≠Âì°„ÇÑÂà©Áî®ËÄÖ„ÅÆÁ≤æÁ•ûÁöÑÂÅ•Â∫∑„ÇíÊêç„Å™„Çè„Å™„ÅÑ„Çà„ÅÜ„ÄÅ‰∫∫Èñì‰∏≠ÂøÉ„ÅÆÈÅãÁî®ÊñπÈáù„ÅåÂÆö„ÇÅ„Çâ„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R2', name: '„É™„Çπ„ÇØË©ï‰æ°', text: 'Â∏∏ÊôÇÊé•Á∂ö„ÄÅÊÉÖÂ†±ÈÅéÂ§ö„ÄÅÂà§Êñ≠„Éó„É¨„ÉÉ„Ç∑„É£„ÉºÁ≠â„ÄÅAI„Åå‰∫∫Èñì„Å´‰∏é„Åà„ÇãÂøÉÁêÜÁöÑË≤†Ëç∑„Éª„Çπ„Éà„É¨„Çπ„É™„Çπ„ÇØ„ÇíË©ï‰æ°„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R3', name: 'Ë®≠Ë®à„ÉªÊ§úË®º', text: 'Ë™çÁü•Ë≤†Ëç∑„Çí‰ΩéÊ∏õ„Åó„ÄÅÈÅéÂ∫¶„Å™‰æùÂ≠ò„ÇÑ‰∏çÂÆâ„ÇíÁîü„Åæ„Å™„ÅÑUI/UX„ÇÑÊ•≠Âãô„Éó„É≠„Çª„Çπ„ÅåË®≠Ë®à„ÉªÊ§úË®º„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R4', name: 'Ë≥áÁî£„Éª„É≠„Ç∞', text: 'AIÈñ¢ÈÄ£Ê•≠Âãô„Å´Âæì‰∫ã„Åô„ÇãÊãÖÂΩìËÄÖ„ÅÆÂä¥ÂÉçÊôÇÈñì„ÄÅ„Çπ„Éà„É¨„Çπ„ÉÅ„Çß„ÉÉ„ÇØÁµêÊûúÁ≠â„ÅÆÂÅ•Â∫∑ÊåáÊ®ô„Éá„Éº„Çø„ÇíÁÆ°ÁêÜ„Åó„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R5', name: 'Áõ£Ë¶ñ„ÉªÊ§úÁü•', text: 'ÈÅãÁî®ÊãÖÂΩìËÄÖ„ÅÆÁáÉ„ÅàÂ∞Ω„ÅçÔºà„Éê„Éº„É≥„Ç¢„Ç¶„ÉàÔºâ„ÅÆÂÖÜÂÄô„ÇÑ„ÄÅÈÅéÂ∫¶„Å™Ë≤†ÊãÖÈõÜ‰∏≠„ÇíÊ§úÁü•„Åô„Çã‰ªïÁµÑ„Åø„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R6', name: 'Â∞Å„ÅòËæº„ÇÅ„ÉªÂæ©Êóß', text: 'ÊãÖÂΩìËÄÖ„ÅÆ„É°„É≥„Çø„É´‰∏çË™øÁô∫ÁîüÊôÇ„Å´„ÄÅÊ•≠Âãô„Åã„Çâ‰∏ÄÊôÇÁöÑ„Å´Èõ¢ËÑ±„Åï„Åõ„ÄÅ„Çµ„Éù„Éº„Éà„Åô„Çã‰ΩìÂà∂„ÅØ„ÅÇ„Çã„Åã„ÄÇ' },
                    { code: 'R7', name: 'ÂØæÂ§ñÂØæÂøú', text: 'Ëá™Á§æ„ÅÆAI„Åå„ÄÅÂà©Áî®ËÄÖÔºàÁâπ„Å´Â≠ê‰æõ„ÇÑËÑÜÂº±„Å™Á´ãÂ†¥„ÅÆ‰∫∫Ôºâ„ÅÆÁ≤æÁ•ûÁöÑÂÅ•Â∫∑„Å´ÊÇ™ÂΩ±Èüø„Çí‰∏é„Åà„Å™„ÅÑÈÖçÊÖÆ„Åå„Å™„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ' },
                    { code: 'R8', name: 'ÊîπÂñÑ„ÉªÊòØÊ≠£', text: 'ÂæìÊ•≠Âì°„Çµ„Éº„Éô„Ç§„ÇÑÂÅ•Â∫∑„Éá„Éº„Çø„Å´Âü∫„Å•„Åç„ÄÅAI„ÇíÁî®„ÅÑ„ÅüÊ•≠Âãô„Éï„É≠„Éº„ÇÑ‰∫∫Âì°‰ΩìÂà∂„ÅÆË¶ãÁõ¥„Åó„ÇíË°å„Å£„Å¶„ÅÑ„Çã„Åã„ÄÇ' }
                ]
            }
        ];

        // ============ GAME STATE ============
        let gameState = {
            checkedItems: new Set(),
            xp: 0,
            level: 1,
            achievements: [],
            selectedDomain: 0
        };

        // Load saved state
        const savedState = localStorage.getItem('aiGovernanceState');
        if (savedState) {
            const parsed = JSON.parse(savedState);
            gameState.checkedItems = new Set(parsed.checkedItems || []);
            gameState.xp = parsed.xp || 0;
            gameState.level = parsed.level || 1;
            gameState.achievements = parsed.achievements || [];
        }

        // Achievements definition
        const achievements = [
            { id: 'first_check', name: 'First Steps', desc: 'Complete your first checklist item', icon: 'üéØ', xp: 50, condition: () => gameState.checkedItems.size >= 1 },
            { id: 'domain_complete', name: 'Domain Master', desc: 'Complete all items in one domain', icon: 'üèÜ', xp: 200, condition: () => domainData.some((d, i) => getDomainProgress(i) === 8) },
            { id: 'halfway', name: 'Halfway There', desc: 'Complete 50% of all items', icon: '‚≠ê', xp: 300, condition: () => gameState.checkedItems.size >= 32 },
            { id: 'all_complete', name: 'Governance Master', desc: 'Complete all 64 items', icon: 'üëë', xp: 1000, condition: () => gameState.checkedItems.size >= 64 },
            { id: 'explorer', name: 'Explorer', desc: 'View all 8 domains', icon: 'üîç', xp: 100, condition: () => true }, // Triggered manually
            { id: 'speed_demon', name: 'Speed Demon', desc: 'Complete 10 items in one session', icon: '‚ö°', xp: 150, condition: () => sessionChecks >= 10 }
        ];

        let sessionChecks = 0;
        let viewedDomains = new Set();

        // ============ THREE.JS SETUP ============
        let scene, camera, renderer, nodes = [], connections = [], centralHub;
        let raycaster, mouse;
        let autoRotate = true;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x030305, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas3d'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create visualization
            createCentralHub();
            createNodes();
            createConnections();
            createParticleField();
            createGrid();

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onWheel);
            document.getElementById('canvas3d').addEventListener('click', onClick);

            animate();
        }

        function createCentralHub() {
            // Core sphere
            const coreGeometry = new THREE.IcosahedronGeometry(2, 2);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x00f5ff,
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            centralHub = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(centralHub);

            // Inner glow
            const glowGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00f5ff,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            centralHub.add(glow);

            // Outer rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(2.5 + i * 0.5, 2.6 + i * 0.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00f5ff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3 - i * 0.1
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2 + (i * 0.3);
                ring.rotation.y = i * 0.5;
                centralHub.add(ring);
            }
        }

        function createNodes() {
            const radius = 12;

            domainData.forEach((domain, i) => {
                const angle = (i * Math.PI * 2 / 8) - Math.PI / 2;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                const y = Math.sin(i * 0.5) * 2;

                // Node group
                const nodeGroup = new THREE.Group();
                nodeGroup.position.set(x, y, z);
                nodeGroup.userData = { domainIndex: i, type: 'node' };

                // Main sphere
                const geometry = new THREE.IcosahedronGeometry(1.2, 1);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(domain.color),
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                nodeGroup.add(mesh);

                // Inner core
                const coreGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(domain.color),
                    transparent: true,
                    opacity: 0.5
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                nodeGroup.add(core);

                // Orbiting rings
                const ringGeo = new THREE.TorusGeometry(1.5, 0.02, 8, 64);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(domain.color),
                    transparent: true,
                    opacity: 0.4
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.random() * Math.PI;
                nodeGroup.add(ring);

                // Point light
                const light = new THREE.PointLight(new THREE.Color(domain.color), 0.5, 8);
                nodeGroup.add(light);

                nodes.push({
                    group: nodeGroup,
                    mesh: mesh,
                    ring: ring,
                    angle: angle,
                    baseY: y,
                    domain: domain
                });

                scene.add(nodeGroup);
            });
        }

        function createConnections() {
            const material = new THREE.LineBasicMaterial({
                color: 0x00f5ff,
                transparent: true,
                opacity: 0.2
            });

            // Connect adjacent nodes
            for (let i = 0; i < 8; i++) {
                const next = (i + 1) % 8;
                const points = [];

                const start = nodes[i].group.position;
                const end = nodes[next].group.position;

                // Curved connection
                for (let t = 0; t <= 20; t++) {
                    const p = t / 20;
                    const x = start.x + (end.x - start.x) * p;
                    const y = start.y + (end.y - start.y) * p + Math.sin(p * Math.PI) * 2;
                    const z = start.z + (end.z - start.z) * p;
                    points.push(new THREE.Vector3(x, y, z));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material.clone());
                connections.push(line);
                scene.add(line);
            }

            // Connect to center
            nodes.forEach((node, i) => {
                const points = [];
                const start = node.group.position;
                const end = new THREE.Vector3(0, 0, 0);

                for (let t = 0; t <= 15; t++) {
                    const p = t / 15;
                    const x = start.x * (1 - p);
                    const y = start.y * (1 - p) + Math.sin(p * Math.PI) * 1.5;
                    const z = start.z * (1 - p);
                    points.push(new THREE.Vector3(x, y, z));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({
                    color: new THREE.Color(node.domain.color),
                    transparent: true,
                    opacity: 0.15
                });
                const line = new THREE.Line(geometry, lineMat);
                connections.push(line);
                scene.add(line);
            });
        }

        function createParticleField() {
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const radius = 5 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.cos(phi);
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);

                const color = new THREE.Color(domainData[Math.floor(Math.random() * 8)].color);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData.type = 'particles';
            scene.add(particles);
        }

        function createGrid() {
            const gridHelper = new THREE.GridHelper(50, 50, 0x00f5ff, 0x001520);
            gridHelper.position.y = -8;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        // ============ ANIMATION ============
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Auto rotate
            if (autoRotate) {
                targetRotation.y += 0.002;
            }

            // Smooth camera rotation
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            // Update camera position
            const cameraRadius = camera.position.length();
            camera.position.x = Math.sin(currentRotation.y) * Math.cos(currentRotation.x) * cameraRadius;
            camera.position.y = Math.sin(currentRotation.x) * cameraRadius;
            camera.position.z = Math.cos(currentRotation.y) * Math.cos(currentRotation.x) * cameraRadius;
            camera.lookAt(0, 0, 0);

            // Animate central hub
            if (centralHub) {
                centralHub.rotation.y += 0.005;
                centralHub.rotation.x = Math.sin(time * 0.5) * 0.1;
                centralHub.children.forEach((child, i) => {
                    if (child.type === 'Mesh' && child.geometry.type === 'RingGeometry') {
                        child.rotation.z += 0.01 * (i + 1);
                    }
                });
            }

            // Animate nodes
            nodes.forEach((node, i) => {
                // Floating motion
                node.group.position.y = node.baseY + Math.sin(time + i) * 0.5;

                // Rotation
                node.mesh.rotation.x += 0.01;
                node.mesh.rotation.y += 0.015;
                node.ring.rotation.z += 0.02;

                // Pulse based on progress
                const progress = getDomainProgress(i);
                const scale = 1 + (progress / 8) * 0.3 + Math.sin(time * 2 + i) * 0.05;
                node.group.scale.setScalar(scale);

                // Highlight selected
                if (i === gameState.selectedDomain) {
                    node.mesh.material.opacity = 0.9 + Math.sin(time * 4) * 0.1;
                } else {
                    node.mesh.material.opacity = 0.6;
                }
            });

            // Animate connections
            connections.forEach((line, i) => {
                line.material.opacity = 0.1 + Math.sin(time * 2 + i * 0.5) * 0.05;
            });

            // Animate particles
            scene.children.forEach(child => {
                if (child.userData.type === 'particles') {
                    child.rotation.y += 0.0005;
                }
            });

            renderer.render(scene, camera);
            updateMinimap();
        }

        // ============ INTERACTION ============
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                targetRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotation.x));
            }

            previousMousePosition = { x: event.clientX, y: event.clientY };

            // Tooltip
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes.map(n => n.group), true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.domainIndex && obj.userData.domainIndex !== 0) {
                    obj = obj.parent;
                }
                if (obj.userData.domainIndex !== undefined) {
                    const domain = domainData[obj.userData.domainIndex];
                    showTooltip(event.clientX, event.clientY, `${domain.icon} ${domain.name}`);
                }
            } else {
                hideTooltip();
            }
        }

        function onMouseDown(event) {
            if (event.target.tagName === 'CANVAS') {
                isDragging = true;
                autoRotate = false;
                document.getElementById('btnRotate').classList.remove('active');
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(event) {
            const zoomSpeed = 0.002;
            const newZ = camera.position.length() + event.deltaY * zoomSpeed * camera.position.length();
            const clampedZ = Math.max(10, Math.min(50, newZ));
            camera.position.normalize().multiplyScalar(clampedZ);
        }

        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes.map(n => n.group), true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.domainIndex && obj.userData.domainIndex !== 0) {
                    obj = obj.parent;
                }
                if (obj.userData.domainIndex !== undefined) {
                    selectDomain(obj.userData.domainIndex);
                    triggerGlitch();
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ UI FUNCTIONS ============
        function initUI() {
            renderDomainList();
            updateStats();
            updateXP();
        }

        function renderDomainList() {
            const container = document.getElementById('domainList');
            container.innerHTML = domainData.map((domain, i) => {
                const progress = getDomainProgress(i);
                const isComplete = progress === 8;
                return `
                    <div class="domain-card ${i === gameState.selectedDomain ? 'active' : ''} ${isComplete ? 'completed' : ''}"
                         onclick="selectDomain(${i})" data-domain="${i}">
                        <div class="domain-icon" style="border-color: ${domain.color}; color: ${domain.color};">
                            ${domain.icon}
                        </div>
                        <div class="domain-info">
                            <div class="domain-name" style="color: ${domain.color};">${domain.name}</div>
                            <div class="domain-progress">
                                <div class="domain-progress-fill" style="width: ${progress / 8 * 100}%; background: ${domain.color};"></div>
                            </div>
                        </div>
                        <div class="domain-score" style="color: ${domain.color};">${progress}/8</div>
                    </div>
                `;
            }).join('');
        }

        function selectDomain(index) {
            gameState.selectedDomain = index;
            viewedDomains.add(index);

            // Update domain list
            document.querySelectorAll('.domain-card').forEach((card, i) => {
                card.classList.toggle('active', i === index);
            });

            // Update detail panel
            const domain = domainData[index];
            const panel = document.getElementById('detailPanel');
            const header = document.getElementById('detailHeader');

            document.getElementById('detailDomainId').textContent = `DOMAIN.${domain.id}`;
            document.getElementById('detailDomainId').style.color = domain.color;
            document.getElementById('detailDomainName').innerHTML = `<span class="icon">${domain.icon}</span><span style="color: ${domain.color};">${domain.name}</span>`;
            document.getElementById('detailDomainDesc').textContent = domain.desc;
            header.style.borderBottomColor = domain.color;

            // Render processes
            document.getElementById('detailContent').innerHTML = domain.processes.map((proc, pi) => {
                const itemId = `${index}-${pi}`;
                const isChecked = gameState.checkedItems.has(itemId);
                return `
                    <div class="process-card ${isChecked ? 'checked' : ''}" onclick="toggleCheck(${index}, ${pi})" data-item="${itemId}">
                        <div class="process-header">
                            <span class="process-code" style="color: ${domain.color}; border-color: ${domain.color};">${proc.code}</span>
                            <span class="process-name">${proc.name}</span>
                            <div class="process-check">${isChecked ? '‚úì' : ''}</div>
                        </div>
                        <div class="process-text">${proc.text}</div>
                    </div>
                `;
            }).join('');

            panel.classList.add('visible');

            // Check explorer achievement
            if (viewedDomains.size === 8) {
                checkAchievement('explorer');
            }

            // Focus camera on selected node
            focusOnNode(index);
        }

        function focusOnNode(index) {
            const node = nodes[index];
            const angle = node.angle;
            targetRotation.y = -angle + Math.PI / 2;
        }

        function toggleCheck(domainIndex, processIndex) {
            const itemId = `${domainIndex}-${processIndex}`;
            const wasChecked = gameState.checkedItems.has(itemId);

            if (wasChecked) {
                gameState.checkedItems.delete(itemId);
                addXP(-10);
            } else {
                gameState.checkedItems.add(itemId);
                addXP(15);
                sessionChecks++;
                createCheckParticles(domainIndex);
            }

            // Update UI
            const card = document.querySelector(`[data-item="${itemId}"]`);
            if (card) {
                card.classList.toggle('checked', !wasChecked);
                card.querySelector('.process-check').textContent = wasChecked ? '' : '‚úì';
            }

            updateStats();
            renderDomainList();
            saveState();

            // Check achievements
            checkAllAchievements();
        }

        function getDomainProgress(domainIndex) {
            let count = 0;
            for (let i = 0; i < 8; i++) {
                if (gameState.checkedItems.has(`${domainIndex}-${i}`)) count++;
            }
            return count;
        }

        function updateStats() {
            const checked = gameState.checkedItems.size;
            document.getElementById('checkedCount').textContent = checked;
            document.getElementById('completionRate').textContent = Math.round(checked / 64 * 100) + '%';
        }

        function addXP(amount) {
            gameState.xp += amount;

            // Level up check
            const xpForLevel = gameState.level * 100;
            while (gameState.xp >= xpForLevel) {
                gameState.xp -= xpForLevel;
                gameState.level++;
                showLevelUp();
            }

            if (gameState.xp < 0) gameState.xp = 0;

            updateXP();
            saveState();
        }

        function updateXP() {
            const xpForLevel = gameState.level * 100;
            document.getElementById('levelNum').textContent = gameState.level;
            document.getElementById('currentXP').textContent = gameState.xp;
            document.getElementById('maxXP').textContent = xpForLevel;
            document.getElementById('xpFill').style.width = (gameState.xp / xpForLevel * 100) + '%';
        }

        function showLevelUp() {
            showAchievementPopup({
                icon: '‚¨ÜÔ∏è',
                name: `Level ${gameState.level}`,
                desc: 'You leveled up!',
                xp: 0
            });
        }

        function checkAllAchievements() {
            achievements.forEach(achievement => {
                if (!gameState.achievements.includes(achievement.id) && achievement.condition()) {
                    checkAchievement(achievement.id);
                }
            });
        }

        function checkAchievement(achievementId) {
            if (gameState.achievements.includes(achievementId)) return;

            const achievement = achievements.find(a => a.id === achievementId);
            if (achievement) {
                gameState.achievements.push(achievementId);
                addXP(achievement.xp);
                showAchievementPopup(achievement);
                saveState();
            }
        }

        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementIcon').textContent = achievement.icon;
            document.getElementById('achievementName').textContent = achievement.name;
            document.getElementById('achievementDesc').textContent = achievement.desc;
            document.getElementById('achievementXP').textContent = achievement.xp > 0 ? `+${achievement.xp} XP` : '';

            popup.classList.add('show');

            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }

        function createCheckParticles(domainIndex) {
            // Visual feedback for checking item
            const node = nodes[domainIndex];
            const color = new THREE.Color(node.domain.color);

            // Create burst particles
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = node.group.position.x;
                positions[i * 3 + 1] = node.group.position.y;
                positions[i * 3 + 2] = node.group.position.z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.3,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate particles
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                velocities.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: Math.random() * 0.2,
                    z: (Math.random() - 0.5) * 0.3
                });
            }

            let frame = 0;
            const animateParticles = () => {
                frame++;
                const positions = particles.geometry.attributes.position.array;

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    velocities[i].y -= 0.005; // gravity
                }

                particles.geometry.attributes.position.needsUpdate = true;
                particles.material.opacity = 1 - frame / 60;

                if (frame < 60) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };

            animateParticles();
        }

        // ============ MINIMAP ============
        function updateMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 150;
            canvas.height = 150;

            ctx.fillStyle = 'rgba(0, 10, 20, 0.5)';
            ctx.fillRect(0, 0, 150, 150);

            const centerX = 75;
            const centerY = 75;
            const scale = 3;

            // Draw connections
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.2)';
            ctx.lineWidth = 1;
            nodes.forEach((node, i) => {
                const next = nodes[(i + 1) % 8];
                ctx.beginPath();
                ctx.moveTo(centerX + node.group.position.x * scale, centerY + node.group.position.z * scale);
                ctx.lineTo(centerX + next.group.position.x * scale, centerY + next.group.position.z * scale);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((node, i) => {
                const x = centerX + node.group.position.x * scale;
                const y = centerY + node.group.position.z * scale;
                const progress = getDomainProgress(i) / 8;

                ctx.beginPath();
                ctx.arc(x, y, 4 + progress * 3, 0, Math.PI * 2);
                ctx.fillStyle = node.domain.color;
                ctx.globalAlpha = 0.3 + progress * 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;

                if (i === gameState.selectedDomain) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Draw center
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#00f5ff';
            ctx.globalAlpha = 0.5;
            ctx.fill();

            // Draw camera direction
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            const camX = centerX + Math.sin(currentRotation.y) * 20;
            const camY = centerY + Math.cos(currentRotation.y) * 20;
            ctx.lineTo(camX, camY);
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.stroke();
        }

        // ============ UTILITIES ============
        function triggerGlitch() {
            const glitch = document.getElementById('glitchOverlay');
            glitch.style.opacity = '0.3';
            setTimeout(() => glitch.style.opacity = '0', 100);
        }

        function showTooltip(x, y, text) {
            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = text;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('btnRotate').classList.toggle('active', autoRotate);
        }

        function resetCamera() {
            targetRotation = { x: 0.3, y: 0 };
            camera.position.set(0, 5, 25);
            triggerGlitch();
        }

        function exportProgress() {
            const data = {
                checkedItems: Array.from(gameState.checkedItems),
                xp: gameState.xp,
                level: gameState.level,
                achievements: gameState.achievements,
                exportDate: new Date().toISOString(),
                completionRate: Math.round(gameState.checkedItems.size / 64 * 100) + '%'
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-governance-progress-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showAchievementPopup({
                icon: 'üìÅ',
                name: 'Data Exported',
                desc: 'Your progress has been saved',
                xp: 0
            });
        }

        function saveState() {
            localStorage.setItem('aiGovernanceState', JSON.stringify({
                checkedItems: Array.from(gameState.checkedItems),
                xp: gameState.xp,
                level: gameState.level,
                achievements: gameState.achievements
            }));
        }

        // ============ PARTICLES OVERLAY ============
        function initParticlesOverlay() {
            const canvas = document.getElementById('particlesOverlay');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2 + 1,
                    color: domainData[Math.floor(Math.random() * 8)].color
                });
            }

            function animateOverlay() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                });

                requestAnimationFrame(animateOverlay);
            }

            animateOverlay();

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // ============ INIT ============
        document.addEventListener('DOMContentLoaded', () => {
            initThree();
            initUI();
            initParticlesOverlay();
            selectDomain(0);
        });
    </script>
</body>
</html>
